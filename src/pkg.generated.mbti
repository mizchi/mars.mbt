// Generated using `moon info`, DON'T EDIT IT
package "mizchi/mars"

import {
  "mizchi/mars/router",
  "mizchi/mars/router/trie",
  "moonbitlang/async/http",
  "moonbitlang/async/io",
  "moonbitlang/async/socket",
}

// Values
pub fn char_to_lower(Char) -> Char

pub fn compose(Array[Handler]) -> Handler

pub fn find_char(String, Char) -> Int

pub fn handler(async (Context) -> Unit) -> Handler

pub fn hex_to_int(Char) -> Int

pub fn is_debug() -> Bool

pub fn is_whitespace(Char) -> Bool

pub fn set_debug(Bool) -> Unit

pub fn split_by_char(String, Char) -> Array[String]

pub fn substring(String, Int, Int) -> String

pub fn substring_from(String, Int) -> String

pub fn to_lower(String) -> String

pub fn trim(String) -> String

pub fn url_decode(String) -> String

// Errors

// Types and methods
pub(all) struct BackgroundTask {
  task : async () -> Unit
  name : String
}

pub(all) struct Context {
  request : @http.Request
  params : @router.Params
  vars : Variables
  exec_ctx : &ExecCtx
  // private fields
}
pub async fn Context::body(Self) -> String
pub async fn Context::body_json(Self) -> Json?
pub fn Context::conn(Self) -> @http.ServerConnection
pub fn Context::cookie(Self, String) -> String?
pub fn Context::cookies(Self) -> Map[String, String]
pub fn Context::delete_cookie(Self, String) -> Unit
pub async fn Context::end_response(Self) -> Unit
pub fn Context::env_binding(Self, String) -> Json?
pub fn Context::env_var(Self, String) -> String?
pub fn Context::get(Self, String) -> String?
pub fn Context::header(Self, String) -> String?
pub async fn Context::html(Self, String, status? : Int) -> Unit
pub fn Context::is_response_sent(Self) -> Bool
pub async fn Context::json(Self, Json, status? : Int) -> Unit
pub fn Context::meth(Self) -> @http.RequestMethod
pub fn Context::new(@http.Request, @router.Params, @http.ServerConnection, &@io.Reader) -> Self
pub async fn Context::not_found(Self) -> Unit
pub fn Context::param(Self, String) -> String?
pub fn Context::path(Self) -> String
pub fn Context::queries(Self) -> Map[String, String]
pub fn Context::query(Self, String) -> String?
pub async fn Context::redirect(Self, String) -> Unit
pub fn Context::set(Self, String, String) -> Unit
pub fn Context::set_cookie(Self, String, String, max_age? : Int, path? : String, http_only? : Bool, same_site? : String) -> Unit
pub fn Context::set_header(Self, String, String) -> Unit
pub fn Context::set_status(Self, Int) -> Unit
pub async fn Context::sse_start(Self) -> Unit
pub async fn Context::text(Self, String, status? : Int) -> Unit
pub fn Context::wait_until(Self, async () -> Unit, name? : String) -> Unit
pub fn[E : Env, C : ExecCtx] Context::with_env(@http.Request, @router.Params, @http.ServerConnection, &@io.Reader, E, C) -> Self
pub async fn Context::write_raw(Self, String) -> Unit

pub(all) struct EmptyEnv {
}
pub fn EmptyEnv::new() -> Self
pub impl Env for EmptyEnv

pub(all) struct ExecutionContext {
  // private fields
}
pub fn ExecutionContext::deactivate(Self) -> Unit
pub fn ExecutionContext::get_tasks(Self) -> Array[BackgroundTask]
pub fn ExecutionContext::is_active(Self) -> Bool
pub fn ExecutionContext::new() -> Self
pub fn ExecutionContext::pending_count(Self) -> Int
pub async fn ExecutionContext::run_tasks(Self) -> Unit
pub fn ExecutionContext::wait_until(Self, async () -> Unit, name? : String) -> Unit
pub impl ExecCtx for ExecutionContext

pub(all) struct Handler(async (Context) -> Unit)
#deprecated
pub fn Handler::inner(Self) -> async (Context) -> Unit

pub(all) struct MapEnv {
  vars : Map[String, String]
  bindings : Map[String, Json]
}
pub fn MapEnv::new() -> Self
pub fn MapEnv::with_binding(Self, String, Json) -> Self
pub fn MapEnv::with_var(Self, String, String) -> Self
pub impl Env for MapEnv

pub(all) struct PlatformContext {
  conn : @http.ServerConnection
  body_reader : &@io.Reader
}
pub fn PlatformContext::new(@http.ServerConnection, &@io.Reader) -> Self

pub(all) struct Server {
  router : @trie.TrieRouter
  handlers : Array[Handler]
  middlewares : Array[Handler]
  routes : Array[(@router.Method, String, Int)]
}
pub fn Server::all(Self, String, Handler) -> Unit
pub fn Server::delete(Self, String, Handler) -> Unit
pub fn Server::get(Self, String, Handler) -> Unit
pub fn Server::middleware(Self, Handler) -> Unit
pub fn Server::mount(Self, String, Self) -> Unit
pub fn Server::new() -> Self
pub fn Server::new_debug() -> Self
pub fn Server::patch(Self, String, Handler) -> Unit
pub fn Server::post(Self, String, Handler) -> Unit
pub fn Server::put(Self, String, Handler) -> Unit
pub fn Server::query(Self, String, Handler) -> Unit
pub async fn Server::serve(Self, @socket.Addr) -> Unit
pub async fn[E : Env, C : ExecCtx] Server::serve_with_env(Self, @socket.Addr, E, C) -> Unit

pub(all) struct Variables {
  data : Map[String, Json]
}
pub fn Variables::get(Self, String) -> Json?
pub fn Variables::has(Self, String) -> Bool
pub fn Variables::keys(Self) -> Array[String]
pub fn Variables::new() -> Self
pub fn Variables::remove(Self, String) -> Unit
pub fn[V : Var] Variables::set(Self, String, V) -> Unit

// Type aliases

// Traits
pub(open) trait Env {
  get_var(Self, String) -> String?
  get_binding(Self, String) -> Json?
}

pub(open) trait ExecCtx {
  wait_until(Self, async () -> Unit, name~ : String) -> Unit
}

pub(open) trait Var {
  to_json(Self) -> Json
  from_json(Json) -> Self?
}
pub impl Var for Bool
pub impl Var for Double
pub impl Var for String
pub impl Var for Json

